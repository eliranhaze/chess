import chess
import chess.svg
import random

from IPython.display import SVG, display

class Engine(object):

    LOG = True
 
    DEPTH = 3

    SQUARE_VALUE = .1 # value for each square attacked by a piece
    DEF_VALUE = .1 # value for each defender of a given square
    CHECK_VALUE = .15
    PIECE_VALUE = {
            chess.PAWN: 1,
            chess.KNIGHT: 3.2,
            chess.BISHOP: 3.3,
            chess.ROOK: 5,
            chess.QUEEN: 9,
    }
    PIECE_TYPES = (chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN) # minus king

    def __init__(self):
        self.board = chess.Board()

    def play(self, player_color = chess.WHITE, board = None):
        self.board = board if board else chess.Board()
        self.player_color = player_color
        self.color = not self.player_color
        while not self.board.is_game_over():
            if self.board.turn == player_color:
                self._player_move()
            else:
                num_pieces = sum(len(self.board.pieces(ptype,True)) for ptype in chess.PIECE_TYPES)
                num_pieces += sum(len(self.board.pieces(ptype,False)) for ptype in chess.PIECE_TYPES)
                if num_pieces < 8:
                    depth = 3
                elif num_pieces < 16:
                    depth = 2
                else:
                    depth = 1
                move = self._select_move2(depth = 1)
                #move = self._select_move()
                print('playing %s (depth = %s)' % (self.board.san(move), depth))
                self.board.push(move)
            self._display_board()
        print('Game over: %s' % self.board.result())

    def _display_board(self):
        #print('===')
        #print(self.board)
        #print('===')
        #display(SVG(chess.svg.board(self.board, size = 400)))
        display(self.board)
        print(self.board.fen())

    def _log(self, msg):
        if self.LOG:
            print(msg)

    def _player_move(self):
        while True:
            try:
                move = input('your move: ')
                self.board.push_san(move)
                break
            except ValueError:
                print('illegal move: %s' % move)

    def _select_move(self):
        #return random.choice(list(self.board.legal_moves))
        evals = [(self._evaluate_move(m),m) for m in self.board.legal_moves]
        print('evals:')
        for e, m in evals:
            print('%s: %.1f' % (self.board.san(m), e))
        max_eval = max(evals, key = lambda e: e[0])
        top_moves = [m for e,m in evals if e == max_eval[0]]
        return random.choice(top_moves)

    def _select_move2(self, depth = 3):
        top_move = None
        best_val = -9999
        print('evals:')
        turn = self.board.turn
        for move in self.board.legal_moves:
            san = self.board.san(move)
            self.board.push(move)
            ev = self._minimax_evaluate_board(depth = depth, turn = turn)
            if ev > best_val:
                best_val = ev
                top_move = move
            self.board.pop()
            print('%s: %.1f' % (self.board.san(move), ev))
        return top_move

    # TODO: This doesn't work properly because of turn / sign issues - I should switch to proper
    # negamax implementation where values are always relative to white. Just have a function that converts
    # B/W to -1,1, and all will be smooth...
    # - Also must implement pruning if depth = 3 is going to work at all
    # - And depth must be used to discover tactics / checkmates

    def _minimax_evaluate_board(self, depth = None, turn = None):
        if depth is None:
            depth = self.DEPTH
        if turn is None:
            turn = self.board.turn
        if depth == 0 or self.board.is_game_over():
            return self._evaluate_board(turn)
        ev = -9999
        prefix = '==' * (self.DEPTH - depth)
        for move in self.board.legal_moves:
            san = self.board.san(move)
            self.board.push(move)
            self._log('%sevaluating %s' % (prefix, san))
            ev = max(ev, self._minimax_evaluate_board(depth - 1, turn = not turn))
            self._log('%seval %s: %.1f' % (prefix, san, ev))
            self.board.pop()
        return -ev
    
    def _evaluate_move(self, m, check_recaptures = 3):
        # evaluate board after move (by engine!)

        mover_color = self.board.turn

        prefix = '-' * (4-check_recaptures)
        san = self.board.san(m)
        self._log('%sevaluating %s for %s' % (prefix, self.board.san(m), ['black','white'][int(mover_color)]))
        self.board.push(m)

        ev = self._evaluate_board(mover_color, check_recaptures)
        self._log('%seval for %s: %.1f' % (prefix, san, ev))

        self.board.pop()
        return ev

    def _evaluate_board(self, turn, check_recaptures = 3):

        if self.board.is_checkmate():
            return 999 

        if self.board.is_stalemate() or self.board.is_insufficient_material(): # TODO: add repetition
            return 0

        # piece evaluation
        ev = sum(self._score(t, mover_color)-self._score(t, other_color) for t in self.PIECE_TYPES)

        # general evaluation
        if self.board.is_check():
            ev += self.CHECK_VALUE

        ev += self._king_safety_score() # less valuable in endgame, so adjust for that, maybe should be a function of opponent pieces

        # TODO: check double pawns (not just for pawn moves -- it's an evaluation of the entire board)
        # TODO: + any enemy pieces pinned according to their value maybe
        """
        # check if player has any captures back
        # TODO: might want to check this first as it might obvious the above eval
        if check_recaptures:
            captures = [lm for lm in self.board.legal_moves if self.board.is_capture(lm)]
            if captures:
                re_ev = -max(self._evaluate_move(c, check_recaptures - 1) for c in captures)
                if captures == list(self.board.legal_moves):
                    # forced capture, so eval is real
                    ev = re_ev
                else:
                    # if not foirced, use recapture ev only to avoid worse situations as it only checks subsequent captures
                    ev = min(ev, re_ev)
        # TODO: check forced checks in the same way maybe
        """

        return ev

    def _score(self, piece_type, color):
        return sum(self._piece_score(p, piece_type, color) for p in self.board.pieces(piece_type, color))

    def _piece_score(self, piece, piece_type, color):
        piece_value = self.PIECE_VALUE[piece_type]
        squares_value = self.SQUARE_VALUE * len(self.board.attacks(piece))
        defense_value = self.DEF_VALUE * len(self.board.attackers(color=color,square=piece))
        score = piece_value + squares_value + defense_value
        if self.board.is_pinned(color, piece):
            score -= .1 # maybe tenth of piece value?
        if piece_type == chess.PAWN:
            rank = chess.square_rank(piece)
            if color == chess.BLACK:
                rank = 7 - rank
                bonus = rank ** 3 / 300
                score += bonus
                #print('pawn bonus for %s: %.2f' % (chess.square_name(piece), bonus))
        return score

        # TODO: check x ray as well, to help rooks move to files without pawns for example
        # TODO: + bonus for advanced pawns, right now they don't know about promoting other than when they're on 7th rank
        # TODO: + attacking actual pieces, depending on piece value attacked, to find forks etc
        # TODO: - being attacked by pieces - although that may be covered already in capture search

    def _king_safety_score(self):
        # calc king safety for the player whose turn it is
        color = self.board.turn
        king = self.board.king(color)
        score = 0
        for piece_type in self.PIECE_TYPES:
            for piece in self.board.pieces(piece_type, color):
                if chess.square_distance(king, piece) == 1:
                    score += self.PIECE_VALUE[piece_type]**.2 / 10
        score += chess.square_distance(king, chess.square(4,0)) / 12 # dist from e1 # TODO this should work for both players!!!
        score += chess.square_distance(king, chess.square(4,0)) / 12 # dist from e4
        #self._log('...king safety score: %.2f' % score)
        return score

    #def _enemy_king_space(self): # for checkmates

"""
for endgame checkmate / mate nets - calculate the continuous space in which the king can move - will want to minimize for enemy king

def get_adj(sq):
    rank = chess.square_rank(sq)
    file = chess.square_file(sq)
    adj = []
    for i in (-1,0,1):
        if 0 <= rank+i <= 7:
            for j in (-1,0,1):
                if 0 <= file+j <= 7 and not (i == 0 and j == 0):
                    adj.append(chess.square(file+j, rank+i))
    return adj

def cont_space(sq, checked = None):
    c = 0
    if not checked:
        checked = set()
    #print('checked: %s' % checked)
    checked.add(sq)
    for a in get_adj(sq):
        if a in checked:
            continue
        checked.add(a)
        if not e.board.piece_at(a) and not e.board.is_attacked_by(chess.BLACK, a):
            c += 1 + cont_space(a, checked)
    return c

"""
